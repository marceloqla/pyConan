import shared_globals
from Levenshtein import ratio
import conan_constants
from conan_bool_helpers import isAA
from conan_aln_helpers import sortedSizeSequences, aa2id
from conan_graph_helpers import getNodes
import numpy as np

def hmmFiltering():
	"""
	Returns new MSA from global MSA var excluding sequences with a minimum number of Stockholm format HMM positions
	below the userinput.minocc frequency defined by user
	"""
	# global msa, minocc
	new_msa = {}
	hmmValidPositions = []
	seq = list(shared_globals.msa.items())[0][1]

	for i,aa in enumerate(seq):
		if aa == '-' or aa.isupper():
			hmmValidPositions.append(i)
	for name,seq in shared_globals.msa.items():
		nValidPos = 0
		for i in hmmValidPositions:
			if isAA(seq[i],False):
				nValidPos+=1
		if float(nValidPos)/float(len(hmmValidPositions)) >= shared_globals.minocc:
			new_msa[name] = seq
	return new_msa

def maxIdFiltering():
	"""
	WARN: Unused function. Current implementation uses conan_aln_helpers.py maxIdCDhit function

	Returns new MSA from the sorted global MSA var (see sortedSizeSequences in conan_aln_helpers.py)
	excluding the smallest sequence from any sequence pair containing a identities
	equal or above the userinput.maxid frequency defined by user
	"""
	# global maxid
	sortedSeqs = sortedSizeSequences()
	new_msa = {}
	cluster_N = 0
	total = len(sortedSeqs)
	count = 0

	for seqname1,sequence1 in sortedSeqs:
		print("Max identity filtering... (" + str(count) + "/" + str(total) + ")")
		count += 1
		if(cluster_N == 0):
			cluster_N += 1
			new_msa[seqname1] = sequence1 #Ainda sem gaps
		else:
			found = False
			for seqname2,sequence2 in new_msa.items():
				similarity = ratio(sequence1,sequence2)
				if similarity >= shared_globals.maxid:
					found = True
					break
			if(not found):
				new_msa[seqname1] = sequence1

	for seqname in new_msa.keys():
		new_msa[seqname] = shared_globals.msa[seqname]
	return new_msa

#TODO: Add sequence based restrictions (i.e sets all residues not from sequence as gaps)
def seqbasedFiltering(header):
	"""
	Filters residues in the global msa if they do not belong to a given msa sequence

	Algorithm works by rewriting aln, setting residues > maxfreq or < minfreq as gaps
	The global msa variable sequences is then replaced by the new sequences. Removed are counted for both cases

	Freqlist is generated by freq of AA and returned
	"""
	# global msa
	if header not in shared_globals.msa.keys():
		print("Error: " + header + " not in msa.")
		quit()
	headersequence = shared_globals.msa[header]
	removed = 0

	for seqname,sequence in shared_globals.msa.items():
		new_seq = ""
		for i,(aa, aaref) in enumerate((sequence, headersequence)):
			if aa == '.':
				new_seq += '-'
			elif aa != aaref:
				new_seq += '-'
				removed += 1
			else:
				new_seq += aa.upper()
		shared_globals.msa[seqname] = new_seq
	return (removed)

def residueFiltering():
	"""
	Filters residues in the global msa by their minimum and maximum frequency thresholds defined by the
	global user input vars minfreq and max freq.

	Algorithm works by rewriting aln, setting residues > maxfreq or < minfreq as gaps
	The global msa variable sequences is then replaced by the new sequences. Removed are counted for both cases

	Freqlist is generated by freq of AA and returned
	"""
	# global msa, maxfreq, minfreq
	freqList = []
	N = len(shared_globals.msa)
	seq = list(shared_globals.msa.items())[0][1]
	removed = [0,0]

	for i,aa in enumerate(seq):
		frequencies = np.zeros(22)
		for sequence in shared_globals.msa.values():
			aa = sequence[i]
			aaid = aa2id(aa)
			frequencies[aaid] += 1.0
		frequencies /= N
		freqList.append(frequencies)

	for seqname,sequence in shared_globals.msa.items():
		new_seq = ""
		for i,aa in enumerate(sequence):
			aaid = aa2id(aa)
			freq = freqList[i][aaid]
			if aa == '.':
				new_seq += '-'
			#elif freq > maxfreq or freq < minfreq:
			elif freq > shared_globals.maxfreq:
				new_seq += '-'
				removed[0] += 1
			elif freq < shared_globals.minfreq:
				new_seq += '-'
				removed[1] += 1
			else:
				new_seq += aa.upper()
		shared_globals.msa[seqname] = new_seq
	return (removed,freqList)